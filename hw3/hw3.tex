\documentclass[10pt,letterpaper]{report}
\usepackage[utf8]{inputenc}
\usepackage[margin=0.65in]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{fancyvrb}
\usepackage{appendix}
\usepackage{listings}
\usepackage{multicol}
\usepackage{color}

\author{Marc Evangelista}
\title{Problem Set 3}
\begin{document}
\begin{flushright}
Marc Evangelista \\
MATH 4175 \\ 
CRN: 94509 \\
Problem Set 3 \\
Due: 2013/09/16
\end{flushright}
	All indexing in this document starts at 0 unless otherwise specified.
\begin{enumerate}

	\item Consider the linear recurrence $z_{m+5} \equiv z_m + z_{m+1}$
	(mod 2) of degree 5. For each of the 32 possible initialization vectors (i.e. the 32 initial fills),
	determine the period of the resulting keystream.
	\par
	First, we need to generate the 32 possible initialization vectors. Since we have
	0 and 1 for our bits, and five places, we have $2^5 = 32$ permutations of bits as
	shown:
	\begin{multicols}{4}
	\begin{verbatim}
	00000
	00001
	00010
	00011
	00100
	00101
	00110
	00111
	01000
	01001
	01010
	01011
	01100
	01101
	01110
	01111
	10000
	10001
	10010
	10011
	10100
	10101
	10110
	10111
	11000
	11001
	11010
	11011
	11100
	11101
	11110
	11111
	\end{verbatim}
	\end{multicols}

	\par
	Since we have our initial five bits, we can calculate the proceeding values 
	in our keystream using
	the linear recurrence formula $z_{m+5} \equiv z_m + z_{m+1}$ (mod 2). For example, using
	$00111$ as our vector, our next 5 bits would be as shown:
	\begin{align*}
	z_{0+5} &\equiv z_0 + z_{0+1}\ (mod \ 2) \\
	z_5 &= 0 + 0 = 0 \\
	z_6 &= 0 + 1 = 1 \\
	z_7 &= 1 + 1 = 0 \\
	z_8 &= 1 + 1 = 0 \\
	z_9 &= 1 + 0 = 1
	\end{align*}
	
	So the resulting string is $0011101001$. 
	\par	
	Now to find the period of the keystream,
	we just need to generate a string of at least twice the maximum period length in
	order to confirm the repetition. The
	maximum period for linear recurrence is $2^m - 1$ bits, so in our case it would be
	$2^{5} - 1 = 31$ bits. Therefore, we would need to generate a keystream of at least 62
	bits because if the repeat string is 31 bits, we can at least see it repeat once.
	
	Here are the resulting 62-bit keystreams ordered with respect to our initial vectors.
	\begin{quote}
	\begin{verbatim}
	00000000000000000000000000000000000000000000000000000000000000
	00001000110010101111100001000110010101111100001000110010101111
	00010001100101011111000010001100101011111000010001100101011111
	00011001010111110000100011001010111110000100011001010111110000
	00100011001010111110000100011001010111110000100011001010111110
	00101011111000010001100101011111000010001100101011111000010001
	00110010101111100001000110010101111100001000110010101111100001
	00111010011101001110100111010011101001110100111010011101001110
	01000110010101111100001000110010101111100001000110010101111100
	01001110100111010011101001110100111010011101001110100111010011
	01010111110000100011001010111110000100011001010111110000100011
	01011111000010001100101011111000010001100101011111000010001100
	01100101011111000010001100101011111000010001100101011111000010
	01101101101101101101101101101101101101101101101101101101101101
	01110100111010011101001110100111010011101001110100111010011101
	01111100001000110010101111100001000110010101111100001000110010
	10000100011001010111110000100011001010111110000100011001010111
	10001100101011111000010001100101011111000010001100101011111000
	10010101111100001000110010101111100001000110010101111100001000
	10011101001110100111010011101001110100111010011101001110100111
	10100111010011101001110100111010011101001110100111010011101001
	10101111100001000110010101111100001000110010101111100001000110
	10110110110110110110110110110110110110110110110110110110110110
	10111110000100011001010111110000100011001010111110000100011001
	11000010001100101011111000010001100101011111000010001100101011
	11001010111110000100011001010111110000100011001010111110000100
	11010011101001110100111010011101001110100111010011101001110100
	11011011011011011011011011011011011011011011011011011011011011
	11100001000110010101111100001000110010101111100001000110010101
	11101001110100111010011101001110100111010011101001110100111010
	11110000100011001010111110000100011001010111110000100011001010
	11111000010001100101011111000010001100101011111000010001100101
	\end{verbatim}
	\end{quote}
	
	All that's left is to find the repeating string in each keystream.
	For that, we use the \verb|findrepeat()| function found in
	Listing \ref{lst:vectors}. Following is our final results ordered with respect
	to our original vectors:
	\begin{quote}
	\begin{verbatim}
	string:repeated string:period
	=============================
	00000000000000000000000000000000000000000000000000000000000000:0:1
00001000110010101111100001000110010101111100001000110010101111:000010001100101011111:21
00010001100101011111000010001100101011111000010001100101011111:000100011001010111110:21
00011001010111110000100011001010111110000100011001010111110000:000110010101111100001:21
00100011001010111110000100011001010111110000100011001010111110:001000110010101111100:21
00101011111000010001100101011111000010001100101011111000010001:001010111110000100011:21
00110010101111100001000110010101111100001000110010101111100001:001100101011111000010:21
00111010011101001110100111010011101001110100111010011101001110:0011101:7
01000110010101111100001000110010101111100001000110010101111100:010001100101011111000:21
01001110100111010011101001110100111010011101001110100111010011:0100111:7
01010111110000100011001010111110000100011001010111110000100011:010101111100001000110:21
01011111000010001100101011111000010001100101011111000010001100:010111110000100011001:21
01100101011111000010001100101011111000010001100101011111000010:011001010111110000100:21
01101101101101101101101101101101101101101101101101101101101101:011:3
01110100111010011101001110100111010011101001110100111010011101:0111010:7
01111100001000110010101111100001000110010101111100001000110010:011111000010001100101:21
10000100011001010111110000100011001010111110000100011001010111:100001000110010101111:21
10001100101011111000010001100101011111000010001100101011111000:100011001010111110000:21
10010101111100001000110010101111100001000110010101111100001000:100101011111000010001:21
10011101001110100111010011101001110100111010011101001110100111:1001110:7
10100111010011101001110100111010011101001110100111010011101001:1010011:7
10101111100001000110010101111100001000110010101111100001000110:101011111000010001100:21
10110110110110110110110110110110110110110110110110110110110110:101:3
10111110000100011001010111110000100011001010111110000100011001:101111100001000110010:21
11000010001100101011111000010001100101011111000010001100101011:110000100011001010111:21
11001010111110000100011001010111110000100011001010111110000100:110010101111100001000:21
11010011101001110100111010011101001110100111010011101001110100:1101001:7
11011011011011011011011011011011011011011011011011011011011011:110:3
11100001000110010101111100001000110010101111100001000110010101:111000010001100101011:21
11101001110100111010011101001110100111010011101001110100111010:1110100:7
11110000100011001010111110000100011001010111110000100011001010:111100001000110010101:21
11111000010001100101011111000010001100101011111000010001100101:111110000100011001010:21
	\end{verbatim}
	\end{quote}
	
	
	\item Suppose we build a linear feedback shift register machine (LFSR) that works
	mod 3 instead of mod 2. It uses a recurrence of length 2 of the form
	$x_{n+2} \equiv c_0 x_n + c_1 x_{n+1}$ mod 3 to generate the sequence
	1, 1, 0, 2, 2, 0, 1, 1. Set up and solve the matrix equation to find the coefficients
	$c_0$ and $c_1$.
	
	\par
	To solve for the two variables, we need two equations. We will use the values 0 and 1
	for $n$ for the given equation.
	\begin{align*}
	 c_0 x_0 + c_1 x_1 &\equiv x_{2}   \ (mod\ 3)\\
	 c_0 x_1 + c_1 x_2  &\equiv x_{3}  \ (mod\ 3)
	\end{align*}
	
	We can model this as matrices:
	\begin{align*}
	\begin{pmatrix}
	x_0 & x_1 \\ x_1 & x_2
	\end{pmatrix}
	\begin{pmatrix}
	c_0 \\ c_1
	\end{pmatrix}
	&=
	\begin{pmatrix}
	x_2 \\ x_3
	\end{pmatrix}
	\ (mod\ 3) 	
	\\
	\begin{pmatrix}
	1 & 1 \\ 1 & 0
	\end{pmatrix}
	\begin{pmatrix}
	c_0 \\ c_1
	\end{pmatrix}
	&=
	\begin{pmatrix}
	0 \\ 2
	\end{pmatrix}
	\ (mod\ 3)
	\end{align*}
	
	To solve, we find $\begin{pmatrix}
	1 & 1 \\ 1 & 0
	\end{pmatrix}^{-1}$, and multiply both sides by it to get the coefficient vector
	by itself.
	\begin{align*}
	\begin{pmatrix}
	1 & 1 \\ 1 & 0
	\end{pmatrix}^{-1} &= \frac{1}{(1)(0) - (1)(1)} \begin{pmatrix}
	0 & -1 \\ -1 & 1
	\end{pmatrix} \ (mod\ 3)
	\\
	&= -1 \begin{pmatrix}
	0 & -1 \\ -1 & 1
	\end{pmatrix} \ (mod\ 3)
	\\
	&= 2 \begin{pmatrix}
	0 & 2 \\ 2 & 1
	\end{pmatrix} \ (mod\ 3)
	\\
	&= \begin{pmatrix}
	0 & 1 \\ 1 & 2
	\end{pmatrix} \ (mod\ 3)
	\end{align*}
	
	Putting it back into our original equation:
	\begin{align*}
	\begin{pmatrix}
	1 & 1 \\ 1 & 0
	\end{pmatrix}^{-1}
	\begin{pmatrix}
	1 & 1 \\ 1 & 0
	\end{pmatrix}
	\begin{pmatrix}
	c_0 \\ c_1
	\end{pmatrix}
	&=
	\begin{pmatrix}
	1 & 1 \\ 1 & 0
	\end{pmatrix}^{-1}
	\begin{pmatrix}
	0 \\ 2
	\end{pmatrix}
	\ (mod\ 3)	
	\\
	\begin{pmatrix}
	c_0 \\ c_1
	\end{pmatrix}
	&=
	\begin{pmatrix}
	0 & 1 \\ 1 & 2
	\end{pmatrix}
	\begin{pmatrix}
	0 \\ 2
	\end{pmatrix}
	\ (mod\ 3)
	\\
	&=
	\begin{pmatrix}
	2 \\ 1
	\end{pmatrix} \ (mod\ 3)
	\end{align*}
	
	At last we have $c_0 = 2$ and $c_1 = 1$.

\end{enumerate}


\begin{appendices}
\chapter{Code Listings}
\lstinputlisting[language=Python, 
				breaklines=true,
				numbers=left,
				caption=problem1.py,
				label={lst:vectors}]{vectors.py}

\chapter{Program Output}
\end{appendices}
\end{document}